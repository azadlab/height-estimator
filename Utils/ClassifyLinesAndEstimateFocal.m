function [bestClassification, info] = ClassifyLinesAndEstimateFocal(lines, ParaList)
%%This function is to classify lines and estimate the camea focal length according to their directions in the Manhattan world.
%Input:  lines      --  the extracted lines from image, line(i,:) = [i, startPointx, startPointy, endPointx, endPointy]
%                       Note: The principal point (or image center) is the origin of the
%                       image coordinate frame. (Not the top-left corner)
%        ParaList.kMaxNumHyp
%                   --  the max number of hypotheses generated in the ransac procedure. The
%                       adaptive method (see Hartley and Zisserman, p. 120) for determining number
%                       of hypotheses will stop when reaches this number.
%        ParaList.kMinNumHyp 
%                   --  the min number of hypotheses in the ransac procedure that will be
%                       generated before the adaptive method (see Hartley and Zisserman, p. 120) kicks in.
%        ParaList.kAcceptHypothesisThreshold
%                    -- threshold to accept a hypothesis. When more than this percent (e.g. 85%) inliers are established
%                       by a hypothesis, then stop test the other hypotheses.
%        ParaList.kInClassResidualThreshold 
%                    -- the threshold to decide whether to accept a line within a class (Xdir, Ydir or Zdir)
%        ParaList.kConsistencyMeasure
%                    -- the method to compute the residual of a line with respect to a vanishing point: '1 for CM1' or '2 for CM2'. 
%        ParaList.kRefineMethod 
%                    -- the way to refine the estimated values and classification results: 'Iter' or 'MLE'.
%Output: bestClassification 
%                    -- A row vectors with numbers from 0-3, corresponding to each line input in
%                       lines. 0 indicates the outliers, and 1-3 denote one of the three
%                       cardinal classes assigned to the line.
%        info       --  A data structure containing basic debugging information. The field names
%                       are self explanatory.

timeStart  = tic;
% get the number of lines
numOfLines = size(lines,1);

kMaxNumHyp                = ParaList.kMaxNumHyp;
kMinNumHyp                = ParaList.kMinNumHyp;
kAcceptHypothesisThreshold= ParaList.kAcceptHypothesisThreshold;
kInClassResidualThreshold = ParaList.kInClassResidualThreshold;
kConsistencyMeasure       = ParaList.kConsistencyMeasure;
kRefineMethod             = ParaList.kRefineMethod;

if kConsistencyMeasure == 1
    linePlaneNormal = zeros(numOfLines,3);%linePlaneNormal(i,:)=[nx,ny,nz]
    % compute the normal of the interpretation plane of each line in the camera frame.
    % The focal length will be compensated latter. We first get [nx, ny, nz] = [xs, ys, 1] x [xe, ye, 1]
    % then planeNormal = [xs, ys, focal] x [xe, ye, focal] = [focal * nx, focal * ny, nz]
    for i=1:numOfLines
        normal_c = cross([lines(i,2:3),1], [lines(i,4:5),1]);
        linePlaneNormal(i,:) = normal_c;%[nx, ny, nz] = [xs, ys, 1] x [xe, ye, 1]
    end
elseif kConsistencyMeasure == 2
    %compute the middle points of image lines which equals to 0.5*(sx+ex, sy+ey)
    middlePoints = 0.5*(lines(:,2:3) + lines(:,4:5));
else 
    error('Please choose the correct consistency measure method. Either 1 for CM1 or 2 for CM2');
end

% compute the histogram of image line directions.
% We observe that for at least one of the Manhattan directions, a large number of its corresponding 
% lines are close to parallel in the image plane. This maybe invalid in some special cases, so the usual RANSAC approach is still employed.
histogramLen = 15;% the resolution of each bin is 180/15 = 12 degrees.
dirHistogram = zeros(histogramLen,1);%store the histogram of image line directions.
dirCell      = cell(histogramLen,1);%store line IDs in each cell. 
resolution   = pi/histogramLen;
dx           = lines(:,4) - lines(:,2);% dx = ex-sx;
dy           = lines(:,5) - lines(:,3);% dy = ey-sy;
for lineID = 1: numOfLines
    dir   = atan(dy(lineID)/dx(lineID));% range from -pi/2 to pi/2.
    binID = max(ceil((dir+pi/2)/resolution),1); % when dy<0 and dx=0, dir will be -pi/2, then cell((dir+pi/2)/resolution) = 0;
    dirHistogram(binID) = dirHistogram(binID) + 1; 
    dirCell{binID}      = [dirCell{binID}, lineID];
end
%pick the bin which includes the largest number of lines
[numLinesInpeak1, peakID1] = max(dirHistogram);

%separate the input lines according to two situations.
%situationA: most of the image lines included in the largest bin
%            correspond to the same Manhattan direction;
%situationB: the corresponding Manhattan directions of image lines in the
%            largest bin are randomly distributed.
%For situationA, the hypotheses are generated by two steps: first randomly
%pick two lines from the largest bin, then sample two lines from the rest of bins. The hypotheses are
%tested by assuming that two lines from the largest bin are parallel and the other two lines are either orthogonal
%or parallel mutually but orthogonal to the first two lines.
%For situationB, four lines are randomly sampled and all nine admissible cases (six cases in configuration 1
%and three cases in configuration 2 in Sec.4) are tested.

%Initialize the best results
bestClassification = zeros(numOfLines,1);
bestVPXYZ          = zeros(3,3);
bestFocal          = 0;
bestHypothesis     = [];
bestNumInliers     = 0;

 
%%%%%%%%%%%%%%%%%%the following code is to generate and test hypotheses for situationA;
lineIDPart1A  = dirCell{peakID1}; %all the lines in the peakID1 bin forms the first part of situationA.
lineIDPart2A  = [];% the rest of lines
for binID = 1:histogramLen
    %all the lines not in the peakID1 bin form the second part of situationA.
    if binID ~= peakID1        
        lineIDPart2A = [lineIDPart2A, dirCell{binID}];
    end
end
numLinesInPart2A = size(lineIDPart2A,2);
% generate unique random hypotheses
kMaxID = numLinesInpeak1*(numLinesInpeak1-1)*numLinesInPart2A*(numLinesInPart2A-1)/4;
%generate more hypotheses to ensure enough unique hypotheses available
randomValues = rand(1,ceil(kMinNumHyp*1.5));
randomCompositeID = ceil(randomValues*(kMaxID-1e-8));
[~,indexInA,~] = unique(randomCompositeID);
% ensure that no more than # of unique lines are requested
indexInB   = sort(indexInA);
kMinNumHyp = min(length(indexInB),kMinNumHyp);
randomCompositeID = randomCompositeID(indexInB(1:kMinNumHyp));

%test all kMinNumHyp hypotheses for situation A.
bFast = 1;
fourLines = zeros(4,5);
for hypCount = 1:kMinNumHyp
    % get the sample subset which includes four lines for situationA.
    hypSelectLines = GetCase4LineInSituationA(randomCompositeID(hypCount), numLinesInpeak1, numLinesInPart2A);
    fourLines(1,:) = lines(lineIDPart1A(hypSelectLines(1)),:);
    fourLines(2,:) = lines(lineIDPart1A(hypSelectLines(2)),:);
    fourLines(3,:) = lines(lineIDPart2A(hypSelectLines(3)),:);
    fourLines(4,:) = lines(lineIDPart2A(hypSelectLines(4)),:);    
    % compute the vanishing points for this subset
    [vanishingPoint, focal, numofResults] = SolveHypVPF( fourLines, bFast);
    % count the inliers, if more than previous, update the best hypothesis
    for resulutsID = 1: numofResults
        newClassification = zeros(numOfLines,1);
        vpXYZ   = vanishingPoint(:,3*resulutsID-2 : 3*resulutsID);
        focal_i = focal(resulutsID); 
        %when two vanishing points are far from the image center, the estimation of focal is not accurate. 
        if focal_i<200  || focal_i > 1000
            continue;
        end
        if kConsistencyMeasure==1 %'CM1'
            for lineID = 1:numOfLines
                planeNormal = linePlaneNormal(lineID, :);
                planeNormal(3) = planeNormal(3)/focal_i;
                planeNormal = planeNormal/norm(planeNormal);
                res = abs(planeNormal * vpXYZ);
                minvalue = sum(abs(res)<0.09);%line may be consistent with two vanishing points
                [minRes, minClass] = min(res);
                % if one of the residuals is less than threshold, classify the line accordingly
                if minRes < kInClassResidualThreshold && minvalue<2
                    newClassification(lineID) = minClass;
                end
            end            
        else % kConsistencyMeasure==2, CM2
            %first convert the vanishing points in space to image plane.
            kMat = [focal_i, 0, 0; 0, focal_i, 0; 0, 0, 1];
            vpXYZInImage = kMat*vpXYZ;
            %compute the distances of start points to the ideal line in the image plane. 
            for lineID = 1:numOfLines
                mp          = [middlePoints(lineID,:) , 1];%homogenous coordinate
                startPoint  = [lines(lineID,2:3), 1];
                mpSkew      = [0, -mp(3), mp(2); mp(3), 0, -mp(1); -mp(2), mp(1), 0]; % [mp]x
                idealLines  = mpSkew * vpXYZInImage;% three ideal lines 
                distances   = abs(startPoint * idealLines);%[sp*idealLine1, sp*idealLine2, sp*idealLine3];
                temp        = sqrt(idealLines(1,:).*idealLines(1,:)+idealLines(2,:).*idealLines(2,:));    
                distances   = distances./temp;
                minvalue    = sum(distances<0.9);%line may be consistent with two vanishing points
                [minDis, minClass] = min(distances);
                % if one of the residuals is less than threshold, classify the line accordingly
                if minDis < kInClassResidualThreshold && minvalue<2
                    newClassification(lineID) = minClass;
                end
            end            
        end
        newNumInliers = sum(newClassification ~= 0);
         % if more inliers are detected with this hyp, update the best hyp
        if newNumInliers > bestNumInliers
             bestNumInliers     = newNumInliers;
             bestClassification = newClassification;
             bestVPXYZ          = vpXYZ;
             bestFocal          = focal_i;
             bestHypothesis     = [lineIDPart1A(hypSelectLines(1)), lineIDPart1A(hypSelectLines(2)),...
                                   lineIDPart2A(hypSelectLines(3)), lineIDPart2A(hypSelectLines(4))];
        end
        if bestNumInliers/numOfLines > kAcceptHypothesisThreshold
            break;
        end        
    end
    if bestNumInliers/numOfLines > kAcceptHypothesisThreshold
        break;
    end
end

%%%%%%%%%%%%%%%%%%the following code is to generate and test hypotheses for situationB;
% The adaptive RANSAC method is employed.
if bestNumInliers/numOfLines < kAcceptHypothesisThreshold
    bFast = 0;
    log01 = log(0.01);
    %generate more hypotheses to ensure enough unique hypotheses available
    randomCompositeID = rand(ceil(kMaxNumHyp*1.5), 4) * numOfLines;
    randomCompositeID = ceil(randomCompositeID);
    [~, indexInA, ~] = unique(randomCompositeID, 'rows');
    % ensure that no more than # of unique lines are requested
    indexInB   = sort(indexInA);
    kMaxNumHyp = min(length(indexInB),kMaxNumHyp); 
    hypSelectLinesMat    =  randomCompositeID(indexInB(1:kMaxNumHyp),:);
    
    % hypotheses  evaluation loop
    numHyp = kMaxNumHyp;% numHyp will be adaptive adjusted.
    hypCount = 0;
    while  hypCount < numHyp
        hypCount = hypCount + 1;
        % get the sample subset
        hypSelectLines = hypSelectLinesMat(hypCount,:);
        % compute the vanishing points for this subset
        [vanishingPoint, focal, numofResults] = SolveHypVPF( lines(hypSelectLines,:), bFast);
        % count the inliers, if more than previous, update the best hypothesis
        for resulutsID = 1: numofResults
            newClassification = zeros(numOfLines,1);
            vpXYZ   = vanishingPoint(:,3*resulutsID-2 : 3*resulutsID);
            focal_i = focal(resulutsID);
            %when two vanishing points are far from the image center, the estimation of focal is not accurate.
            if focal_i<200  || focal_i > 1000
                continue;
            end
            if kConsistencyMeasure==1 %'CM1'
                for lineID = 1:numOfLines
                    planeNormal = linePlaneNormal(lineID, :);
                    planeNormal(3) = planeNormal(3)/focal_i;
                    planeNormal    = planeNormal/norm(planeNormal);
                    res            = abs(planeNormal * vpXYZ);
                    minvalue       = sum(abs(res)<0.09);
                    [minRes, minClass] = min(res);
                    % if one of the residuals is less than threshold, classify the line accordingly
                    if minRes < kInClassResidualThreshold && minvalue<2
                        newClassification(lineID) = minClass;
                    end
                end
            else % kConsistencyMeasure==2, CM2
                %first convert the vanishing points in space to image plane.
                kMat = [focal_i, 0, 0; 0, focal_i, 0; 0, 0, 1];
                vpXYZInImage = kMat*vpXYZ;
                %compute the distances of start points to the ideal line in the image plane.
                for lineID = 1:numOfLines
                    mp          = [middlePoints(lineID,:) , 1];%homogenous coordinate
                    startPoint  = [lines(lineID,2:3), 1];
                    mpSkew      = [0, -mp(3), mp(2); mp(3), 0, -mp(1); -mp(2), mp(1), 0]; % [mp]x
                    idealLines  = mpSkew * vpXYZInImage;% three ideal lines
                    distances   = abs(startPoint * idealLines);%[sp*idealLine1, sp*idealLine2, sp*idealLine3];
                    temp        = sqrt(idealLines(1,:).*idealLines(1,:)+idealLines(2,:).*idealLines(2,:));
                    distances   = distances./temp;
                    minvalue    = sum(distances<0.9);%line may be consistent with two vanishing points
                    [minDis, minClass] = min(distances);
                    % if one of the residuals is less than threshold, classify the line accordingly
                    if minDis < kInClassResidualThreshold && minvalue<2
                        newClassification(lineID) = minClass;
                    end
                end
            end
            newNumInliers = sum(newClassification ~= 0);
            % if more inliers are detected with this hyp, update the best hyp
            if newNumInliers > bestNumInliers
                bestNumInliers     = newNumInliers;
                bestClassification = newClassification;
                bestVPXYZ          = vpXYZ;
                bestFocal          = focal_i;
                bestHypothesis     = hypSelectLines;
                newNumHyp          = ceil(log01/log(1-(newNumInliers/numOfLines)^3)); %adaptive adjustment
                numHyp             = max(min(kMaxNumHyp,newNumHyp), kMinNumHyp);
            end
            if bestNumInliers/numOfLines > kAcceptHypothesisThreshold
                break;
            end
        end
    end %end while hypCount < numHyp
end
timeToRansac = toc(timeStart);

if bestFocal<100
    info.success = 0;
    return;
end

% finally, refine the best vanishing point estimation and re-classify
timeStartRefine = tic;
if strcmp(kRefineMethod, 'Iter') 
    %Use Newton iteration, only inliers are used because the model of outlier is missing.
    [refinedBestVPXYZ, refinedBestFocal, residual] = RefineVPAndFocalByNewtonIteration(...
                                                     lines(bestClassification ~= 0,:), ...
                                                     bestVPXYZ, bestFocal, bestClassification(bestClassification ~= 0),...
                                                     kConsistencyMeasure);
elseif strcmp(kRefineMethod, 'MLE')
    %Use maximum likelihood estimator, all lines are used.
    [refinedBestVPXYZ, refinedBestFocal, residual] = RefineVPAndFocalByMLE(...
                                                     lines, bestVPXYZ, bestFocal, bestClassification,...
                                                     kConsistencyMeasure);
else 
  error('Please choose the correct way to refine: Iter or MLE');
end

timeToRefine = toc(timeStartRefine);

%re-classify.
newClassification = zeros(1,numOfLines);
if refinedBestFocal>100
    if kConsistencyMeasure==1 %'CM1'
        for lineID = 1:numOfLines
            planeNormal = linePlaneNormal(lineID, :);
            planeNormal(3) = planeNormal(3)/refinedBestFocal;
            planeNormal = planeNormal/norm(planeNormal);
            res = abs(planeNormal * refinedBestVPXYZ);
            minvalue = sum(abs(res)<0.09);
            [minRes, minClass] = min(res);
            if minRes < kInClassResidualThreshold && minvalue<2
                newClassification(lineID) = minClass;
            end
        end
    else %'CM2'
        %first convert the vanishing points in space to image plane.
        kMat = [refinedBestFocal, 0, 0; 0, refinedBestFocal, 0; 0, 0, 1];
        vpXYZInImage = kMat*refinedBestVPXYZ;
        %compute the distances of start points to the ideal line in the image plane.
        for lineID = 1:numOfLines
            mp          = [middlePoints(lineID,:) , 1];%homogenous coordinate
            startPoint  = [lines(lineID,2:3), 1];
            mpSkew      = [0, -mp(3), mp(2); mp(3), 0, -mp(1); -mp(2), mp(1), 0]; % [mp]x
            idealLines  = mpSkew * vpXYZInImage;% three ideal lines
            distances   = abs(startPoint * idealLines);%[sp*idealLine1, sp*idealLine2, sp*idealLine3];
            temp        = sqrt(idealLines(1,:).*idealLines(1,:)+idealLines(2,:).*idealLines(2,:));
            distances   = distances./temp;
            minvalue    = sum(distances<0.9);%line may be consistent with two vanishing points
            [minDis, minClass] = min(distances);
            % if one of the residuals is less than threshold, classify the line accordingly
            if minDis < kInClassResidualThreshold && minvalue<2
                newClassification(lineID) = minClass;
            end
        end
    end
end
newNumInliers     = sum(newClassification ~= 0);
isbetter = 0;
if newNumInliers>bestNumInliers%get better results
    bestClassification = newClassification;
    bestNumInliers     = newNumInliers;
    isbetter = 1;
else
    refinedBestVPXYZ   = bestVPXYZ;
    refinedBestFocal   = bestFocal;
end

% create the output arguments
info.oldBestVp    = bestVPXYZ;
info.oldBestFocal = bestFocal;
info.bestVP       = refinedBestVPXYZ;
info.bestFocal    = refinedBestFocal;
info.hypCount     = hypCount;
info.bestNumInliersRatio= bestNumInliers/numOfLines;
info.bestHypothesis = bestHypothesis;
info.isbetter     = isbetter;
info.timeToRansac = timeToRansac;
info.timeToRefine = timeToRefine;
info.success      = 1;
